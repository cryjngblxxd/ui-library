-- // Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- // Global Tables
if not getgenv then getgenv = function() return _G end end
getgenv().Toggles = getgenv().Toggles or {}
getgenv().Options = getgenv().Options or {}

local Toggles = getgenv().Toggles
local Options = getgenv().Options

-- // Library
local Library = {
	Windows = {},
	OpenDropdown = nil,
	ToggleKeybind = nil,
	Unloaded = false,
	Theme = {
		Accent = Color3.fromRGB(0, 140, 255),
		Main = Color3.fromRGB(18, 18, 18),
		Background = Color3.fromRGB(12, 12, 12),
		Sidebar = Color3.fromRGB(15, 15, 15),
		Border = Color3.fromRGB(40, 40, 40),
		Text = Color3.fromRGB(220, 220, 220),
		TextDim = Color3.fromRGB(120, 120, 120),
		Font = Enum.Font.Code,
		CornerRadius = 4
	}
}

-- // Utility
local function Create(class, props, children)
	local obj = Instance.new(class)
	for k, v in pairs(props or {}) do
		if k ~= "Parent" then obj[k] = v end
	end
	if children then
		for _, c in pairs(children) do c.Parent = obj end
	end
	if props and props.Parent then obj.Parent = props.Parent end
	return obj
end

local function AddCorner(parent, radius)
	return Create("UICorner", { Parent = parent, CornerRadius = UDim.new(0, radius or Library.Theme.CornerRadius) })
end

local function AddStroke(parent, color, thickness)
	return Create("UIStroke", { Parent = parent, Color = color or Library.Theme.Border, Thickness = thickness or 1 })
end

local function Tween(obj, props, time)
	return TweenService:Create(obj, TweenInfo.new(time or 0.15, Enum.EasingStyle.Quad), props):Play()
end

local function GetKeyName(key)
	if not key then return "..." end
	local name = tostring(key.Name or key)
	if name:find("MouseButton") then
		name = "MB" .. name:gsub("MouseButton", "")
	end
	return name
end

local function IsMouseOver(frame)
	local mouse = UserInputService:GetMouseLocation()
	local pos, size = frame.AbsolutePosition, frame.AbsoluteSize
	return mouse.X >= pos.X and mouse.X <= pos.X + size.X and mouse.Y >= pos.Y and mouse.Y <= pos.Y + size.Y
end

-- // GUI Setup
local ScreenGui = Create("ScreenGui", {
	Name = "LinoriaStyle",
	Parent = Players.LocalPlayer:WaitForChild("PlayerGui"),
	ResetOnSpawn = false,
	ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
	IgnoreGuiInset = true
})

-- Dropdown Holder (Always on top)
local DropdownHolder = Create("Frame", {
	Parent = ScreenGui,
	BackgroundTransparency = 1,
	Size = UDim2.new(1, 0, 1, 0),
	ZIndex = 100
})

-- Keybind List Frame
local KeybindFrame = Create("Frame", {
	Parent = ScreenGui,
	BackgroundColor3 = Library.Theme.Background,
	Position = UDim2.new(0, 10, 0.5, -100),
	Size = UDim2.new(0, 180, 0, 0),
	AutomaticSize = Enum.AutomaticSize.Y,
	Visible = false,
	ZIndex = 90
})
AddCorner(KeybindFrame)
AddStroke(KeybindFrame, Library.Theme.Accent)
Create("UIPadding", { Parent = KeybindFrame, PaddingTop = UDim.new(0,6), PaddingBottom = UDim.new(0,6), PaddingLeft = UDim.new(0,8), PaddingRight = UDim.new(0,8) })
local KeybindList = Create("UIListLayout", { Parent = KeybindFrame, Padding = UDim.new(0, 4), SortOrder = Enum.SortOrder.LayoutOrder })
Library.KeybindFrame = KeybindFrame

local KeybindItems = {}

-- // KeyPicker Class
local KeyPicker = {}
KeyPicker.__index = KeyPicker

function KeyPicker.new(idx, info, parent)
	local self = setmetatable({}, KeyPicker)
	self.Idx = idx
	self.Value = nil
	self.Mode = info.Mode or "Toggle"
	self.Text = info.Text or idx
	self.NoUI = info.NoUI or false
	self.SyncToggleState = info.SyncToggleState or false
	self.Callback = info.Callback
	self.ChangedCallback = info.ChangedCallback
	self._onClickCallbacks = {}
	self._onChangedCallbacks = {}
	self._state = false
	self.ParentToggle = nil
	
	-- Parse default
	local defaultKey = info.Default
	if type(defaultKey) == "string" then
		if defaultKey:match("^MB%d$") then
			local num = defaultKey:match("%d")
			self.Value = Enum.UserInputType["MouseButton" .. num]
		else
			pcall(function() self.Value = Enum.KeyCode[defaultKey] end)
		end
	elseif typeof(defaultKey) == "EnumItem" then
		self.Value = defaultKey
	end
	
	-- UI
	self.Button = Create("TextButton", {
		Parent = parent,
		BackgroundColor3 = Library.Theme.Main,
		Size = UDim2.new(0, 50, 0, 18),
		Position = UDim2.new(1, -50, 0.5, -9),
		Font = Library.Theme.Font,
		TextSize = 10,
		TextColor3 = Library.Theme.TextDim,
		Text = "[" .. GetKeyName(self.Value) .. "]",
		AutoButtonColor = false
	})
	AddCorner(self.Button, 3)
	AddStroke(self.Button)
	
	-- Keybind List Entry
	if not self.NoUI then
		self.ListEntry = Create("TextLabel", {
			Parent = KeybindFrame,
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 0, 16),
			Font = Library.Theme.Font,
			TextSize = 11,
			TextColor3 = Library.Theme.TextDim,
			Text = self.Text .. " [" .. self.Mode .. "]",
			TextXAlignment = Enum.TextXAlignment.Left,
			Visible = false
		})
		KeybindItems[idx] = self.ListEntry
	end
	
	-- Click to bind
	local binding = false
	self.Button.MouseButton1Click:Connect(function()
		if binding then return end
		binding = true
		self.Button.Text = "[...]"
		self.Button.TextColor3 = Library.Theme.Accent
		
		local conn
		conn = UserInputService.InputBegan:Connect(function(input, gpe)
			if gpe then return end
			local valid = input.UserInputType == Enum.UserInputType.Keyboard or 
			              input.UserInputType == Enum.UserInputType.MouseButton1 or
			              input.UserInputType == Enum.UserInputType.MouseButton2 or
			              input.UserInputType == Enum.UserInputType.MouseButton3
			
			if valid then
				binding = false
				local key = input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode or input.UserInputType
				
				if key == Enum.KeyCode.Escape then
					self.Value = nil
					self.Button.Text = "[...]"
				else
					self.Value = key
					self.Button.Text = "[" .. GetKeyName(key) .. "]"
				end
				
				self.Button.TextColor3 = Library.Theme.TextDim
				conn:Disconnect()
				
				for _, cb in ipairs(self._onChangedCallbacks) do cb() end
				if self.ChangedCallback then self.ChangedCallback(key) end
			end
		end)
	end)
	
	-- Right click for mode
	self.Button.MouseButton2Click:Connect(function()
		local modes = {"Toggle", "Hold", "Always"}
		local idx = table.find(modes, self.Mode) or 1
		idx = idx % #modes + 1
		self.Mode = modes[idx]
		
		if self.ListEntry then
			self.ListEntry.Text = self.Text .. " [" .. self.Mode .. "]"
		end
		
		-- Apply mode immediately
		if self.Mode == "Always" then
			self:SetState(true)
		elseif self.Mode == "Hold" then
			self:SetState(false)
		end
	end)
	
	Options[idx] = self
	return self
end

function KeyPicker:SetState(state)
	if self._state == state then return end
	self._state = state
	
	if self.ListEntry then
		self.ListEntry.Visible = state
	end
	
	if self.SyncToggleState and self.ParentToggle then
		self.ParentToggle:SetValue(state)
	end
	
	if self.Callback then self.Callback(state) end
	for _, cb in ipairs(self._onClickCallbacks) do cb() end
end

function KeyPicker:GetState()
	if self.Mode == "Always" then return true end
	return self._state
end

function KeyPicker:OnClick(cb)
	table.insert(self._onClickCallbacks, cb)
end

function KeyPicker:OnChanged(cb)
	table.insert(self._onChangedCallbacks, cb)
end

function KeyPicker:SetValue(data)
	if type(data) == "table" then
		local keyName, mode = data[1], data[2]
		if keyName then
			if keyName:match("^MB%d$") then
				self.Value = Enum.UserInputType["MouseButton" .. keyName:match("%d")]
			else
				pcall(function() self.Value = Enum.KeyCode[keyName] end)
			end
			self.Button.Text = "[" .. GetKeyName(self.Value) .. "]"
		end
		if mode then
			self.Mode = mode
			if self.ListEntry then
				self.ListEntry.Text = self.Text .. " [" .. self.Mode .. "]"
			end
		end
	end
end

-- Input handling for keypickers
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe or Library.Unloaded then return end
	
	for idx, picker in pairs(Options) do
		if picker.Value and (picker.Value == input.KeyCode or picker.Value == input.UserInputType) then
			if picker.Mode == "Always" then
				-- Already on
			elseif picker.Mode == "Hold" then
				picker:SetState(true)
			elseif picker.Mode == "Toggle" then
				picker:SetState(not picker._state)
			end
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if Library.Unloaded then return end
	
	for idx, picker in pairs(Options) do
		if picker.Value and picker.Mode == "Hold" and (picker.Value == input.KeyCode or picker.Value == input.UserInputType) then
			picker:SetState(false)
		end
	end
end)

-- // Toggle Class
local Toggle = {}
Toggle.__index = Toggle

function Toggle.new(parent, idx, info)
	local self = setmetatable({}, Toggle)
	self.Idx = idx
	self.Value = info.Default or false
	self.Text = info.Text or idx
	self.Tooltip = info.Tooltip
	self.Callback = info.Callback
	self._onChangedCallbacks = {}
	self.KeyPicker = nil
	
	self.Frame = Create("Frame", {
		Parent = parent,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, 22)
	})
	
	self.Box = Create("TextButton", {
		Parent = self.Frame,
		BackgroundColor3 = Library.Theme.Main,
		Size = UDim2.new(0, 14, 0, 14),
		Position = UDim2.new(0, 0, 0.5, -7),
		Text = "",
		AutoButtonColor = false
	})
	AddCorner(self.Box, 3)
	AddStroke(self.Box)
	
	self.Checkmark = Create("TextLabel", {
		Parent = self.Box,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Font = Enum.Font.GothamBold,
		TextSize = 12,
		TextColor3 = Library.Theme.Accent,
		Text = "✓",
		Visible = self.Value
	})
	
	self.Label = Create("TextLabel", {
		Parent = self.Frame,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 22, 0, 0),
		Size = UDim2.new(1, -80, 1, 0),
		Font = Library.Theme.Font,
		TextSize = 12,
		TextColor3 = self.Value and Library.Theme.Text or Library.Theme.TextDim,
		Text = self.Text,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	self.Box.MouseButton1Click:Connect(function()
		-- Check if keypicker prevents toggling
		if self.KeyPicker then
			local mode = self.KeyPicker.Mode
			if mode == "Always" then return end
			if mode == "Hold" then return end
		end
		self:SetValue(not self.Value)
	end)
	
	Toggles[idx] = self
	return self
end

function Toggle:SetValue(val)
	self.Value = val
	self.Checkmark.Visible = val
	self.Label.TextColor3 = val and Library.Theme.Text or Library.Theme.TextDim
	Tween(self.Box, { BackgroundColor3 = val and Library.Theme.Accent or Library.Theme.Main }, 0.1)
	
	if self.Callback then self.Callback(val) end
	for _, cb in ipairs(self._onChangedCallbacks) do cb() end
end

function Toggle:OnChanged(cb)
	table.insert(self._onChangedCallbacks, cb)
end

function Toggle:AddKeyPicker(idx, info)
	info.SyncToggleState = info.SyncToggleState or false
	local picker = KeyPicker.new(idx, info, self.Frame)
	picker.ParentToggle = self
	self.KeyPicker = picker
	return picker
end

function Toggle:AddColorPicker(idx, info)
	-- Simplified color picker
	local btn = Create("TextButton", {
		Parent = self.Frame,
		BackgroundColor3 = info.Default or Color3.new(1,1,1),
		Size = UDim2.new(0, 20, 0, 14),
		Position = UDim2.new(1, -25, 0.5, -7),
		Text = "",
		AutoButtonColor = false
	})
	AddCorner(btn, 3)
	AddStroke(btn)
	
	Options[idx] = {
		Value = info.Default or Color3.new(1,1,1),
		Transparency = info.Transparency or 0,
		SetValueRGB = function(self, col) 
			self.Value = col 
			btn.BackgroundColor3 = col
		end,
		OnChanged = function() end
	}
	return Options[idx]
end

-- // Slider Class
local Slider = {}
Slider.__index = Slider

function Slider.new(parent, idx, info)
	local self = setmetatable({}, Slider)
	self.Idx = idx
	self.Min = info.Min or 0
	self.Max = info.Max or 100
	self.Rounding = info.Rounding or 0
	self.Suffix = info.Suffix or ""
	self.Value = info.Default or self.Min
	self.Compact = info.Compact or false
	self.Callback = info.Callback
	self._onChangedCallbacks = {}
	
	local height = self.Compact and 20 or 34
	
	self.Frame = Create("Frame", {
		Parent = parent,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, height)
	})
	
	if not self.Compact then
		self.Title = Create("TextLabel", {
			Parent = self.Frame,
			BackgroundTransparency = 1,
			Size = UDim2.new(0.5, 0, 0, 14),
			Font = Library.Theme.Font,
			TextSize = 11,
			TextColor3 = Library.Theme.Accent,
			Text = info.Text or idx,
			TextXAlignment = Enum.TextXAlignment.Left
		})
		
		self.ValueLabel = Create("TextLabel", {
			Parent = self.Frame,
			BackgroundTransparency = 1,
			Position = UDim2.new(0.5, 0, 0, 0),
			Size = UDim2.new(0.5, 0, 0, 14),
			Font = Library.Theme.Font,
			TextSize = 11,
			TextColor3 = Library.Theme.Text,
			Text = tostring(self.Value) .. self.Suffix,
			TextXAlignment = Enum.TextXAlignment.Right
		})
	end
	
	self.SliderBg = Create("Frame", {
		Parent = self.Frame,
		BackgroundColor3 = Library.Theme.Main,
		Position = UDim2.new(0, 0, 0, self.Compact and 2 or 18),
		Size = UDim2.new(1, 0, 0, self.Compact and 16 or 12),
		BorderSizePixel = 0
	})
	AddCorner(self.SliderBg)
	AddStroke(self.SliderBg)
	
	local pct = (self.Value - self.Min) / (self.Max - self.Min)
	self.Fill = Create("Frame", {
		Parent = self.SliderBg,
		BackgroundColor3 = Library.Theme.Accent,
		Size = UDim2.new(pct, 0, 1, 0),
		BorderSizePixel = 0
	})
	AddCorner(self.Fill)
	
	local function Update(input)
		local pct = math.clamp((input.Position.X - self.SliderBg.AbsolutePosition.X) / self.SliderBg.AbsoluteSize.X, 0, 1)
		local raw = self.Min + (self.Max - self.Min) * pct
		local val = math.floor(raw * (10 ^ self.Rounding)) / (10 ^ self.Rounding)
		self.Value = val
		self.Fill.Size = UDim2.new(pct, 0, 1, 0)
		if self.ValueLabel then self.ValueLabel.Text = tostring(val) .. self.Suffix end
		
		if self.Callback then self.Callback(val) end
		for _, cb in ipairs(self._onChangedCallbacks) do cb() end
	end
	
	self.SliderBg.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			Update(input)
			local move, up
			move = UserInputService.InputChanged:Connect(function(i)
				if i.UserInputType == Enum.UserInputType.MouseMovement then Update(i) end
			end)
			up = UserInputService.InputEnded:Connect(function(i)
				if i.UserInputType == Enum.UserInputType.MouseButton1 then
					move:Disconnect()
					up:Disconnect()
				end
			end)
		end
	end)
	
	Options[idx] = self
	return self
end

function Slider:SetValue(val)
	val = math.clamp(val, self.Min, self.Max)
	self.Value = val
	local pct = (val - self.Min) / (self.Max - self.Min)
	self.Fill.Size = UDim2.new(pct, 0, 1, 0)
	if self.ValueLabel then self.ValueLabel.Text = tostring(val) .. self.Suffix end
	
	if self.Callback then self.Callback(val) end
	for _, cb in ipairs(self._onChangedCallbacks) do cb() end
end

function Slider:OnChanged(cb)
	table.insert(self._onChangedCallbacks, cb)
end

-- // Dropdown Class
local Dropdown = {}
Dropdown.__index = Dropdown

function Dropdown.new(parent, idx, info)
	local self = setmetatable({}, Dropdown)
	self.Idx = idx
	self.Values = info.Values or {}
	self.Multi = info.Multi or false
	self.SpecialType = info.SpecialType
	self.Callback = info.Callback
	self._onChangedCallbacks = {}
	self.Open = false
	
	-- Handle default
	if self.Multi then
		self.Value = {}
		if type(info.Default) == "table" then
			self.Value = info.Default
		elseif info.Default then
			self.Value[self.Values[1] or info.Default] = true
		end
	else
		if type(info.Default) == "number" then
			self.Value = self.Values[info.Default] or self.Values[1]
		else
			self.Value = info.Default or self.Values[1]
		end
	end
	
	-- Special: Player dropdown
	if self.SpecialType == "Player" then
		self.Values = {}
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= Players.LocalPlayer then
				table.insert(self.Values, p.Name)
			end
		end
		Players.PlayerAdded:Connect(function(p)
			table.insert(self.Values, p.Name)
			self:Refresh()
		end)
		Players.PlayerRemoving:Connect(function(p)
			table.remove(self.Values, table.find(self.Values, p.Name))
			self:Refresh()
		end)
	end
	
	self.Frame = Create("Frame", {
		Parent = parent,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, 42)
	})
	
	Create("TextLabel", {
		Parent = self.Frame,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, 14),
		Font = Library.Theme.Font,
		TextSize = 11,
		TextColor3 = Library.Theme.TextDim,
		Text = info.Text or idx,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local displayText = self.Multi and self:GetMultiText() or (self.Value or "...")
	
	self.Button = Create("TextButton", {
		Parent = self.Frame,
		BackgroundColor3 = Library.Theme.Main,
		Position = UDim2.new(0, 0, 0, 16),
		Size = UDim2.new(1, 0, 0, 24),
		Font = Library.Theme.Font,
		TextSize = 11,
		TextColor3 = Library.Theme.Text,
		Text = displayText,
		AutoButtonColor = false,
		ClipsDescendants = true
	})
	AddCorner(self.Button)
	AddStroke(self.Button)
	
	self.Arrow = Create("TextLabel", {
		Parent = self.Button,
		BackgroundTransparency = 1,
		Position = UDim2.new(1, -20, 0, 0),
		Size = UDim2.new(0, 16, 1, 0),
		Font = Library.Theme.Font,
		TextSize = 10,
		TextColor3 = Library.Theme.TextDim,
		Text = "▼"
	})
	
	-- Dropdown list (in DropdownHolder for z-index)
	self.List = Create("Frame", {
		Parent = DropdownHolder,
		BackgroundColor3 = Library.Theme.Main,
		Size = UDim2.new(0, 200, 0, 0),
		Visible = false,
		ClipsDescendants = true,
		ZIndex = 101
	})
	AddCorner(self.List)
	AddStroke(self.List, Library.Theme.Accent)
	
	self.Scroll = Create("ScrollingFrame", {
		Parent = self.List,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		CanvasSize = UDim2.new(0, 0, 0, 0),
		ScrollBarThickness = 3,
		ScrollBarImageColor3 = Library.Theme.Accent,
		BorderSizePixel = 0,
		ZIndex = 102
	})
	Create("UIListLayout", { Parent = self.Scroll, Padding = UDim.new(0, 2), SortOrder = Enum.SortOrder.LayoutOrder })
	Create("UIPadding", { Parent = self.Scroll, PaddingTop = UDim.new(0,4), PaddingBottom = UDim.new(0,4), PaddingLeft = UDim.new(0,4), PaddingRight = UDim.new(0,6) })
	
	self:Refresh()
	
	self.Button.MouseButton1Click:Connect(function()
		self:Toggle()
	end)
	
	Options[idx] = self
	return self
end

function Dropdown:GetMultiText()
	local selected = {}
	for k, v in pairs(self.Value) do
		if v then table.insert(selected, k) end
	end
	if #selected == 0 then return "..." end
	return table.concat(selected, ", ")
end

function Dropdown:Refresh()
	for _, c in ipairs(self.Scroll:GetChildren()) do
		if c:IsA("TextButton") then c:Destroy() end
	end
	
	for _, opt in ipairs(self.Values) do
		local isSelected = self.Multi and self.Value[opt] or (self.Value == opt)
		
		local btn = Create("TextButton", {
			Parent = self.Scroll,
			BackgroundColor3 = Library.Theme.Background,
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 0, 22),
			Font = Library.Theme.Font,
			TextSize = 11,
			TextColor3 = isSelected and Library.Theme.Accent or Library.Theme.Text,
			Text = opt,
			AutoButtonColor = false,
			ZIndex = 103
		})
		AddCorner(btn, 3)
		
		btn.MouseEnter:Connect(function()
			btn.BackgroundTransparency = 0
		end)
		btn.MouseLeave:Connect(function()
			btn.BackgroundTransparency = 1
		end)
		
		btn.MouseButton1Click:Connect(function()
			if self.Multi then
				self.Value[opt] = not self.Value[opt]
				btn.TextColor3 = self.Value[opt] and Library.Theme.Accent or Library.Theme.Text
				self.Button.Text = self:GetMultiText()
			else
				self.Value = opt
				self.Button.Text = opt
				self:Close()
				
				-- Update all option colors
				for _, c in ipairs(self.Scroll:GetChildren()) do
					if c:IsA("TextButton") then
						c.TextColor3 = (c.Text == opt) and Library.Theme.Accent or Library.Theme.Text
					end
				end
			end
			
			if self.Callback then self.Callback(self.Value) end
			for _, cb in ipairs(self._onChangedCallbacks) do cb() end
		end)
	end
	
	local count = math.min(#self.Values, 6)
	self.Scroll.CanvasSize = UDim2.new(0, 0, 0, #self.Values * 24 + 8)
	self.ListHeight = count * 24 + 8
end

function Dropdown:Toggle()
	if self.Open then
		self:Close()
	else
		self:OpenList()
	end
end

function Dropdown:OpenList()
	if Library.OpenDropdown and Library.OpenDropdown ~= self then
		Library.OpenDropdown:Close()
	end
	
	self.Open = true
	Library.OpenDropdown = self
	self.Arrow.Text = "▲"
	
	local pos = self.Button.AbsolutePosition
	local size = self.Button.AbsoluteSize
	self.List.Position = UDim2.new(0, pos.X, 0, pos.Y + size.Y + 4)
	self.List.Size = UDim2.new(0, size.X, 0, self.ListHeight or 100)
	self.List.Visible = true
end

function Dropdown:Close()
	self.Open = false
	self.Arrow.Text = "▼"
	self.List.Visible = false
	if Library.OpenDropdown == self then
		Library.OpenDropdown = nil
	end
end

function Dropdown:SetValue(val)
	if self.Multi then
		if type(val) == "table" then
			self.Value = val
		end
		self.Button.Text = self:GetMultiText()
	else
		self.Value = val
		self.Button.Text = val
	end
	self:Refresh()
	
	if self.Callback then self.Callback(self.Value) end
	for _, cb in ipairs(self._onChangedCallbacks) do cb() end
end

function Dropdown:OnChanged(cb)
	table.insert(self._onChangedCallbacks, cb)
end

-- Close dropdown on click outside
UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		if Library.OpenDropdown then
			local dd = Library.OpenDropdown
			if not IsMouseOver(dd.Button) and not IsMouseOver(dd.List) then
				dd:Close()
			end
		end
	end
end)

-- // Input Class
local Input = {}
Input.__index = Input

function Input.new(parent, idx, info)
	local self = setmetatable({}, Input)
	self.Idx = idx
	self.Value = info.Default or ""
	self.Numeric = info.Numeric or false
	self.Finished = info.Finished or false
	self.Placeholder = info.Placeholder or ""
	self.Callback = info.Callback
	self._onChangedCallbacks = {}
	
	self.Frame = Create("Frame", {
		Parent = parent,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, 42)
	})
	
	Create("TextLabel", {
		Parent = self.Frame,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, 14),
		Font = Library.Theme.Font,
		TextSize = 11,
		TextColor3 = Library.Theme.TextDim,
		Text = info.Text or idx,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	self.Box = Create("TextBox", {
		Parent = self.Frame,
		BackgroundColor3 = Library.Theme.Main,
		Position = UDim2.new(0, 0, 0, 16),
		Size = UDim2.new(1, 0, 0, 24),
		Font = Library.Theme.Font,
		TextSize = 11,
		TextColor3 = Library.Theme.Text,
		PlaceholderText = self.Placeholder,
		PlaceholderColor3 = Library.Theme.TextDim,
		Text = self.Value,
		ClearTextOnFocus = false
	})
	AddCorner(self.Box)
	AddStroke(self.Box)
	
	local function OnChange()
		local txt = self.Box.Text
		if self.Numeric then
			txt = txt:gsub("[^%d%.%-]", "")
			self.Box.Text = txt
		end
		self.Value = txt
		if self.Callback then self.Callback(txt) end
		for _, cb in ipairs(self._onChangedCallbacks) do cb() end
	end
	
	if self.Finished then
		self.Box.FocusLost:Connect(OnChange)
	else
		self.Box:GetPropertyChangedSignal("Text"):Connect(OnChange)
	end
	
	Options[idx] = self
	return self
end

function Input:OnChanged(cb)
	table.insert(self._onChangedCallbacks, cb)
end

-- // Label Class
local Label = {}
Label.__index = Label

function Label.new(parent, text, wrap)
	local self = setmetatable({}, Label)
	
	self.Label = Create("TextLabel", {
		Parent = parent,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, wrap and 0 or 18),
		AutomaticSize = wrap and Enum.AutomaticSize.Y or Enum.AutomaticSize.None,
		Font = Library.Theme.Font,
		TextSize = 12,
		TextColor3 = Library.Theme.Text,
		Text = text,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
		TextWrapped = wrap or false
	})
	
	return self
end

function Label:AddKeyPicker(idx, info)
	return KeyPicker.new(idx, info, self.Label)
end

function Label:AddColorPicker(idx, info)
	local btn = Create("TextButton", {
		Parent = self.Label,
		BackgroundColor3 = info.Default or Color3.new(1,1,1),
		Size = UDim2.new(0, 20, 0, 14),
		Position = UDim2.new(1, -25, 0.5, -7),
		Text = "",
		AutoButtonColor = false
	})
	AddCorner(btn, 3)
	AddStroke(btn)
	
	Options[idx] = {
		Value = info.Default or Color3.new(1,1,1),
		Transparency = info.Transparency or 0,
		SetValueRGB = function(self, col) 
			self.Value = col 
			btn.BackgroundColor3 = col
		end,
		OnChanged = function() end
	}
	return Options[idx]
end

-- // Button Class
local Button = {}
Button.__index = Button

function Button.new(parent, info)
	local self = setmetatable({}, Button)
	self.Func = info.Func
	self.DoubleClick = info.DoubleClick or false
	self._lastClick = 0
	
	self.Btn = Create("TextButton", {
		Parent = parent,
		BackgroundColor3 = Library.Theme.Main,
		Size = UDim2.new(1, 0, 0, 24),
		Font = Library.Theme.Font,
		TextSize = 12,
		TextColor3 = Library.Theme.Text,
		Text = info.Text or "Button",
		AutoButtonColor = false
	})
	AddCorner(self.Btn)
	AddStroke(self.Btn)
	
	self.Btn.MouseEnter:Connect(function()
		Tween(self.Btn, { BackgroundColor3 = Library.Theme.Background })
	end)
	self.Btn.MouseLeave:Connect(function()
		Tween(self.Btn, { BackgroundColor3 = Library.Theme.Main })
	end)
	
	self.Btn.MouseButton1Click:Connect(function()
		if self.DoubleClick then
			local now = tick()
			if now - self._lastClick < 0.4 then
				if self.Func then self.Func() end
				self._lastClick = 0
			else
				self._lastClick = now
			end
		else
			if self.Func then self.Func() end
		end
	end)
	
	return self
end

function Button:AddButton(info)
	return Button.new(self.Btn.Parent, info)
end

-- // Divider
local function AddDivider(parent)
	Create("Frame", {
		Parent = parent,
		BackgroundColor3 = Library.Theme.Border,
		Size = UDim2.new(1, 0, 0, 1)
	})
end

-- // Groupbox Class
local Groupbox = {}
Groupbox.__index = Groupbox

function Groupbox.new(parent, name, side)
	local self = setmetatable({}, Groupbox)
	
	self.Frame = Create("Frame", {
		Parent = parent,
		BackgroundColor3 = Library.Theme.Background,
		Size = UDim2.new(0.48, 0, 0, 0),
		AutomaticSize = Enum.AutomaticSize.Y,
		Position = side == "Right" and UDim2.new(0.52, 0, 0, 0) or UDim2.new(0, 0, 0, 0)
	})
	AddCorner(self.Frame)
	AddStroke(self.Frame)
	
	local header = Create("Frame", {
		Parent = self.Frame,
		BackgroundColor3 = Library.Theme.Sidebar,
		Size = UDim2.new(1, 0, 0, 24)
	})
	AddCorner(header)
	Create("Frame", { Parent = header, BackgroundColor3 = Library.Theme.Sidebar, Position = UDim2.new(0,0,1,-6), Size = UDim2.new(1,0,0,6), BorderSizePixel = 0 })
	
	Create("TextLabel", {
		Parent = header,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 10, 0, 0),
		Size = UDim2.new(1, -10, 1, 0),
		Font = Library.Theme.Font,
		TextSize = 12,
		TextColor3 = Library.Theme.Text,
		Text = name,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	Create("Frame", { Parent = header, BackgroundColor3 = Library.Theme.Border, Position = UDim2.new(0,0,1,0), Size = UDim2.new(1,0,0,1), BorderSizePixel = 0 })
	
	self.Container = Create("Frame", {
		Parent = self.Frame,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 10, 0, 30),
		Size = UDim2.new(1, -20, 0, 0),
		AutomaticSize = Enum.AutomaticSize.Y
	})
	Create("UIListLayout", { Parent = self.Container, Padding = UDim.new(0, 6), SortOrder = Enum.SortOrder.LayoutOrder })
	Create("UIPadding", { Parent = self.Container, PaddingBottom = UDim.new(0, 10) })
	
	return self
end

function Groupbox:AddToggle(idx, info)
	return Toggle.new(self.Container, idx, info)
end

function Groupbox:AddSlider(idx, info)
	return Slider.new(self.Container, idx, info)
end

function Groupbox:AddDropdown(idx, info)
	return Dropdown.new(self.Container, idx, info)
end

function Groupbox:AddInput(idx, info)
	return Input.new(self.Container, idx, info)
end

function Groupbox:AddLabel(text, wrap)
	return Label.new(self.Container, text, wrap)
end

function Groupbox:AddButton(info)
	return Button.new(self.Container, info)
end

function Groupbox:AddDivider()
	AddDivider(self.Container)
end

-- // Tab Class
local Tab = {}
Tab.__index = Tab

function Tab.new(parent, name, tabBtn, window)
	local self = setmetatable({}, Tab)
	self.Name = name
	self.Window = window
	self.TabButton = tabBtn
	
	self.Page = Create("ScrollingFrame", {
		Parent = parent,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		CanvasSize = UDim2.new(0, 0, 0, 0),
		AutomaticCanvasSize = Enum.AutomaticSize.Y,
		ScrollBarThickness = 4,
		ScrollBarImageColor3 = Library.Theme.Accent,
		Visible = false,
		BorderSizePixel = 0
	})
	
	self.LeftColumn = Create("Frame", {
		Parent = self.Page,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.48, 0, 0, 0),
		AutomaticSize = Enum.AutomaticSize.Y
	})
	Create("UIListLayout", { Parent = self.LeftColumn, Padding = UDim.new(0, 8), SortOrder = Enum.SortOrder.LayoutOrder })
	
	self.RightColumn = Create("Frame", {
		Parent = self.Page,
		BackgroundTransparency = 1,
		Position = UDim2.new(0.52, 0, 0, 0),
		Size = UDim2.new(0.48, 0, 0, 0),
		AutomaticSize = Enum.AutomaticSize.Y
	})
	Create("UIListLayout", { Parent = self.RightColumn, Padding = UDim.new(0, 8), SortOrder = Enum.SortOrder.LayoutOrder })
	
	return self
end

function Tab:AddLeftGroupbox(name)
	return Groupbox.new(self.LeftColumn, name, "Left")
end

function Tab:AddRightGroupbox(name)
	return Groupbox.new(self.RightColumn, name, "Right")
end

function Tab:AddLeftTabbox()
	-- Simplified tabbox
	return self:AddLeftGroupbox("Tabbox")
end

function Tab:AddRightTabbox()
	return self:AddRightGroupbox("Tabbox")
end

-- // Window Class
local Window = {}
Window.__index = Window

function Window.new(options)
	local self = setmetatable({}, Window)
	self.Title = options.Title or "Window"
	self.Tabs = {}
	self.ActiveTab = nil
	
	local centerX = options.Center and 0.5 or (options.Position and options.Position.X.Scale or 0.5)
	local centerY = options.Center and 0.5 or (options.Position and options.Position.Y.Scale or 0.5)
	local sizeX = options.Size and options.Size.X.Offset or 550
	local sizeY = options.Size and options.Size.Y.Offset or 400
	
	self.Main = Create("Frame", {
		Parent = ScreenGui,
		BackgroundColor3 = Library.Theme.Main,
		Position = UDim2.new(centerX, -sizeX/2, centerY, -sizeY/2),
		Size = UDim2.new(0, sizeX, 0, sizeY),
		Visible = options.AutoShow ~= false
	})
	AddCorner(self.Main, 6)
	AddStroke(self.Main, Library.Theme.Border, 2)
	
	-- Dragging
	local dragging, dragStart, startPos
	self.Main.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = self.Main.Position
		end
	end)
	self.Main.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = input.Position - dragStart
			self.Main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
	
	-- Header
	local header = Create("Frame", { Parent = self.Main, BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 32) })
	Create("TextLabel", {
		Parent = header,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 12, 0, 0),
		Size = UDim2.new(1, -12, 1, 0),
		Font = Library.Theme.Font,
		TextSize = 14,
		TextColor3 = Library.Theme.Accent,
		Text = self.Title,
		TextXAlignment = Enum.TextXAlignment.Left
	})
	
	local headerLine = Create("Frame", { Parent = header, BackgroundColor3 = Library.Theme.Accent, Position = UDim2.new(0, 0, 1, -1), Size = UDim2.new(1, 0, 0, 1) })
	Create("UIGradient", { Parent = headerLine, Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(0.6,0.3), NumberSequenceKeypoint.new(1,1)}) })
	
	-- Body
	local body = Create("Frame", { Parent = self.Main, BackgroundTransparency = 1, Position = UDim2.new(0, 0, 0, 32), Size = UDim2.new(1, 0, 1, -32) })
	
	-- Sidebar
	self.Sidebar = Create("Frame", {
		Parent = body,
		BackgroundColor3 = Library.Theme.Sidebar,
		Size = UDim2.new(0, 130, 1, 0)
	})
	Create("Frame", { Parent = self.Sidebar, BackgroundColor3 = Library.Theme.Border, Position = UDim2.new(1, -1, 0, 0), Size = UDim2.new(0, 1, 1, 0), BorderSizePixel = 0 })
	
	self.TabList = Create("Frame", {
		Parent = self.Sidebar,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 0, 0, 8),
		Size = UDim2.new(1, 0, 1, -8)
	})
	Create("UIListLayout", { Parent = self.TabList, Padding = UDim.new(0, options.TabPadding or 4), SortOrder = Enum.SortOrder.LayoutOrder })
	
	-- Content
	self.Content = Create("Frame", {
		Parent = body,
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 140, 0, 8),
		Size = UDim2.new(1, -150, 1, -16)
	})
	
	return self
end

function Window:AddTab(name)
	local tabBtn = Create("TextButton", {
		Parent = self.TabList,
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 0, 28),
		Font = Library.Theme.Font,
		TextSize = 12,
		TextColor3 = Library.Theme.TextDim,
		Text = name,
		TextXAlignment = Enum.TextXAlignment.Left,
		AutoButtonColor = false
	})
	Create("UIPadding", { Parent = tabBtn, PaddingLeft = UDim.new(0, 14) })
	
	local indicator = Create("Frame", {
		Parent = tabBtn,
		BackgroundColor3 = Library.Theme.Accent,
		Position = UDim2.new(0, -14, 0, 0),
		Size = UDim2.new(0, 2, 1, 0),
		Visible = false
	})
	
	local tab = Tab.new(self.Content, name, tabBtn, self)
	self.Tabs[name] = tab
	
	tabBtn.MouseButton1Click:Connect(function()
		self:SwitchTab(name)
	end)
	
	-- Auto-select first tab
	if not self.ActiveTab then
		self:SwitchTab(name)
	end
	
	return tab
end

function Window:SwitchTab(name)
	if Library.OpenDropdown then
		Library.OpenDropdown:Close()
	end
	
	for tabName, tab in pairs(self.Tabs) do
		local active = tabName == name
		tab.Page.Visible = active
		tab.TabButton.TextColor3 = active and Library.Theme.Accent or Library.Theme.TextDim
		tab.TabButton:FindFirstChild("Frame").Visible = active
	end
	self.ActiveTab = name
end

-- // Library Functions
function Library:CreateWindow(options)
	local win = Window.new(options)
	table.insert(self.Windows, win)
	return win
end

function Library:SetWatermarkVisibility(visible)
	-- Watermark placeholder
end

function Library:SetWatermark(text)
	-- Watermark placeholder
end

function Library:OnUnload(cb)
	self._unloadCallback = cb
end

function Library:Unload()
	Library.Unloaded = true
	if self._unloadCallback then self._unloadCallback() end
	ScreenGui:Destroy()
end

-- Toggle visibility with keybind
UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe or Library.Unloaded then return end
	
	if Library.ToggleKeybind then
		local key = Library.ToggleKeybind.Value
		if key and (input.KeyCode == key or input.UserInputType == key) then
			for _, win in ipairs(Library.Windows) do
				win.Main.Visible = not win.Main.Visible
			end
		end
	elseif input.KeyCode == Enum.KeyCode.End then
		for _, win in ipairs(Library.Windows) do
			win.Main.Visible = not win.Main.Visible
		end
	end
end)

return Library
